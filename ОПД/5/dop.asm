ORG 0x0000
ORG 0x0100
JUMP INPUT_INIT
START: CURRENT_SIMPLE_ID: WORD 0x0000
SUS_SIMPLE: WORD 0x0000
NEEDED: WORD 0x00FD
LD #2
ST (CURRENT_SIMPLE_ID)+
INC
ST $SUS_SIMPLE
FINDING_SIMPLE: LD $CURRENT_SIMPLE_ID
    CMP $NEEDED
    BEQ INPUT_INIT
    LD $SUS_SIMPLE
    PUSH
    LD $CURRENT_SIMPLE_ID
    PUSH
    CALL $IS_SIMPLE
    SWAP
    POP
    SWAP
    POP
    BPL NEXT_SUS
    LD $SUS_SIMPLE
    ST (CURRENT_SIMPLE_ID)+
    NEXT_SUS: LD $SUS_SIMPLE
    ADD #2
    ST $SUS_SIMPLE
    JUMP $FINDING_SIMPLE




INPUT_INIT:
    NUM: WORD 0x0000
    NEWNUM: WORD 0x0000
    INPUT_NUM: IN 0x1D
    AND #0x40
    BEQ INPUT
    IN 0x1C
    PUSH
    CALL CHECK_NUMERIC
    SWAP
    POP
    BMI ERR
    BEQ START

CHECK_NUMERIC:
    CMP #0xF
    BEQ START_OUT
    CMP #0xA
    BEQ ERR_OUT
    JUMP NUMERIC
    ERR_OUT: LD #-1
    RET
    START_OUT: LD #0
    RET
    NUMERIC: LD #1
    RET


IS_SIMPLE: CLA ;STACK: INDEX;RET;CURRENT_SIMPLE;N
    PUSH
    DIVIDED: WORD 0x0000
    TEMP: WORD 0x0000
    DEREF: WORD ?
    CHECKING_SIMPLE_DEVISORS: LD &0
    CMP &2
    BPL IS_SIMPLE_OUT_P
    CLA
    ST $TEMP
    ST $DIVIDED
    LD &0
    ST $DEREF
    LD &3
    OTN: SUB (DEREF)
    ST $TEMP
    LD $DIVIDED
    INC
    ST $DIVIDED
    LD $TEMP
    BMI IS_DIVISOR_OUT
    BEQ IS_DIVISOR_OUT
    JUMP $OTN
    IS_DIVISOR_OUT: BEQ IS_SIMPLE_OUT_N
    LD &0
    INC
    ST &0
    LD $TEMP
    JUMP $CHECKING_SIMPLE_DEVISORS
    IS_SIMPLE_OUT_P: SWAP
    POP
    LD #-1
    RET
    IS_SIMPLE_OUT_N: SWAP
    POP
    LD $DIVIDED
    RET

ERR: IN 0x15
    AND #0x40
    BEQ ERR
    LD #0
    OUT 0x14
    LD #0x1B
    OUT 0x14
    LD #0x2B
    OUT 0x14
    LD #0x3B
    OUT 0x14
    LD #0x4B
    OUT 0x14
    LD #0x5B
    OUT 0x14
    LD #0x6B
    OUT 0x14
    LD #0x7B
    OUT 0x14
    HLT